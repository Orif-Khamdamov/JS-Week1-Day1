## **Lecture 6 - Review**

## Синхронность и асинхронность в JavaScript

Что означает синхронность? Скажем, что у нас есть 2 строки кода. Первая идет за второй. Синхронность означает то, что строка 2 не может запуститься до тех пор, пока строка 1 не закончит своё выполнение.

JavaScript сам по себе однопоточный, что означает то, что только один блок кода может запускаться за раз. Так как движок JS выполняет наш код, обрабатывая строку за строкой, он использует один стек вызова, чтобы продолжать отслеживать код, который выполняется в соответствии с установленным порядком. Тоже самое, что и делает стек — структура данных, которая записывает строки выполняемых инструкций и выполняет их в стиле LIFO, то есть Last In First Out, что переводится как, "последний пришел — первый обслужен”. Давайте посмотрим на живом примере, как это происходит и работает, вот function foo() { foo() отправляется в стек и затем, когда выполнение foo() доходит до return;} foo() прекращается и выкидывается из стека вызовов.

![](https://proweb63.ru/assets/chema/images/blog/blog-003_18022020.png)

Что происходит в Exercise 1: итак, схема выше показывает нам типичное линейное выполнение кода. Когда код из трех console.log объявлений отдается в JS.

Шаг 1: console.log("Print 1") отправляется в стек вызовов и выполняется, после того, как процесс завершится, он будет выкинут из стека. Теперь стек пуст и готов к следующим инструкциям на выполнение.

Шаг 2: Следующей инстукцией на выполнение является console.log("Print 2");, который также отправляется в стек и после выполнения оттуда выкидывается. Всё повторяется до тех пор, пока не останется ничего для выполнения.
Давайте посмотрим на следующий пример:

![](https://proweb63.ru/assets/chema/images/blog/blog-004_18022020.png)

Exercise 2: что же тут происходит на самом деле:
Шаг 1: В стек вызовов попадает первое выполняемое объявление нашего скрипта — вызов функции First(). Во время выполнения в области видимости функции First(), наш движок встречает вызов ещё одной функции — Second().

Шаг 2: Следовательно, вызов функции Second() отправляется в стек вызовов и движок начинает выполнение её содержимого, снова встречаясь с ещё одной функцией Third() внутри Second().

Шаг 3: Функция Third() также отправляется в стек запросов и движок начинается её выполнение. Пока функции Second() и First() находятся в стеке и ждут своей очереди в соответствии с порядком.

Шаг 4: Когда движок сталкивается с return; внутри функции Third(), то это означает завершение Third(). Следовательно Third() выкидывается из стека, как завершенное исполнение. На этом моменте движок возвращается к выполнению Second().

Шаг 5: итак, как только движок столкнется с return;, функция Second() будет выкинута из стека и начнется выполнение First(). Теперь тут нет объявления return внутри области видимости First(), так что выполнится только код до конца его области видимости и First() будет выкинут из стека на шаге 6.

Вот то, как браузер работает с синхронными задачами без привлечения чего-либо ещё, кроме "легендарного” стека вызовов. Но всё становится куда сложнее, когда JavaScript сталкивается с асинхронными задачами.

**Асинхронные задачи**

Что такое вообще — асинхронность? В отличие от синхронности, асинхронность это модель поведения. Предположим, что у нас есть две строчки кода, первая за второй. Первая строка это инструкция, для которой нужно время. итак, первая строка начинает запуск этой инструкции в фоновом режиме, позволяя второй строке запуститься без ожидания завершения первой строки.

Нам нужно такое поведение в случае, когда что-то тормозит. Синхронность может казаться прямолинейной и незатейливой, но всё же может быть медленной. Такие задачи, как обработка изображений, операции с файлами, создание запросов сети и ожидание ответа — всё это может тормозить и быть долгим, производя огромные расчеты в 100 миллионов циклов итераций. Так что такие вещи в стеке запросов превращаются в "задержку”, ну или "blocking” по-английски. Когда стек запросов заблокирован, браузер препятствует вмешательству пользователя и выполнению другого кода до тех пор, пока "задержка” не выполнится и не освободит стек запросов. Таким образом, асинхронные колбэки (callback) используются в таких ситуациях.

Пример: Видимо функция setTimeout() это простейший способ продемонстрировать основы асинхронного поведения.

![](https://proweb63.ru/assets/chema/images/blog/blog-005_18022020.png)

Exercise 3: Давайте рассмотрим стек запросов, который только что увидели:
Шаг 1: Как и обычно console.log("Hello ") отправляется в стек первым и сразу же из него выкидывается после выполнения.

Шаг 2: setTimeout() отправляется в стек, но обратите внимание на то, что console.log("Siddhartha") не может сразу выполниться, так как стоит отсрочка на 2 секунды. Так что пока эта функция для нас исчезнет, но мы позже разберем этот вопрос.

Шаг 3: Само собой, следующая строка это console.log(" I am "), которая отправляется в стек, выполняется и тут же выкидывается из него.

Шаг 4: Сейчас стек запросов пуст и в ожидании.

Шаг 5: Внезапно console.log( "Siddhartha" ) обнаруживается в стеке, после 2-х секунд задержки. Далее setTimeout() выполняется и сразу после этого выкидывается из стека. На 6-м шаге, наш стек оказывается пустым.

что говорит о том, что пусть даже JavaScript и однопоточный, мы можем достичь согласованности действий через асинхронное исполнение задач.

## Промисы

Promise (обычно их так и называют «промисы») – предоставляют удобный способ организации асинхронного кода.

В современном JavaScript промисы часто используются в том числе и неявно, при помощи генераторов, но об этом чуть позже.

Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

![](https://learn.javascript.ru/article/promise/promiseInit.png)

На promise можно навешивать колбэки двух типов:

   - onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
   - onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».

Способ использования, в общих чертах, такой:

   1. Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
   2. Внешний код, получив promise, навешивает на него обработчики.
   3. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Синтаксис создания Promise:

```sh
var promise = new Promise(function(resolve, reject) {
  // Эта функция будет вызвана автоматически

  // В ней можно делать любые асинхронные операции,
  // А когда они завершатся — нужно вызвать одно из:
  // resolve(результат) при успешном выполнении
  // reject(ошибка) при ошибке
})
```

**Пример с setTimeout**

Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:

```sh
'use strict';

// Создаётся объект promise
let promise = new Promise((resolve, reject) => {

  setTimeout(() => {
    // переведёт промис в состояние fulfilled с результатом "result"
    resolve("result");
  }, 1000);

});

// promise.then навешивает обработчики на успешный результат или ошибку
promise
  .then(
    result => {
      // первая функция-обработчик - запустится при вызове resolve
      alert("Fulfilled: " + result); // result - аргумент resolve
    },
    error => {
      // вторая функция - запустится при вызове reject
      alert("Rejected: " + error); // error - аргумент reject
    }
  );
```

В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».

А если бы вместо resolve("result") был вызов reject("error"), то вывелось бы «Rejected: error». Впрочем, как правило, если при выполнении возникла проблема, то reject вызывают не со строкой, а с объектом ошибки типа new Error:

```sh
// Этот promise завершится с ошибкой через 1 секунду
var promise = new Promise((resolve, reject) => {

  setTimeout(() => {
    reject(new Error("время вышло!"));
  }, 1000);

});

promise
  .then(
    result => alert("Fulfilled: " + result),
    error => alert("Rejected: " + error.message) // Rejected: время вышло!
  );
```

Конечно, вместо setTimeout внутри функции промиса может быть и запрос к серверу и ожидание ввода пользователя, или другой асинхронный процесс. Главное, чтобы по своему завершению он вызвал resolve или reject, которые передадут результат обработчикам.

## Async Await

Существует специальный синтаксис для работы с промисами, который называется «async/await». Он удивительно прост для понимания и использования.

У слова async один простой смысл: эта функция всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Например, эта функция возвратит выполненный промис с результатом 1:

```sh
async function f() {
  return 1;
}

f().then(alert); // 1
```

Так что ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис. Согласитесь, достаточно просто? Но это ещё не всё. Есть другое ключевое слово – await, которое можно использовать только внутри async-функций.

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

В этом примере промис успешно выполнится через 1 секунду:

```sh
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();
```

В данном примере выполнение функции остановится на строке (*) до тех пор, пока промис не выполнится. Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса, и браузер отобразит alert-окно «готово!».

Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора. Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.

По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.

**await нельзя использовать в обычных функциях**

Если мы попробуем использовать await внутри функции, объявленной без async, получим синтаксическую ошибку:

```sh
function f() {
  let promise = Promise.resolve(1);
  let result = await promise; // SyntaxError
}
```

Ошибки не будет, если мы укажем ключевое слово async перед объявлением функции. Как было сказано раньше, await можно использовать только внутри async–функций.

Давайте перепишем пример showAvatar() с помощью async/await:

   1. Нам нужно заменить вызовы .then на await.
   2. И добавить ключевое слово async перед объявлением функции.

```sh
async function showAvatar() {

  // запрашиваем JSON с данными пользователя
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  // запрашиваем информацию об этом пользователе из github
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();

  // отображаем аватар пользователя
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  // ждём 3 секунды и затем скрываем аватар
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));

  img.remove();

  return githubUser;
}

showAvatar();
```

Получилось очень просто и читаемо, правда? Гораздо лучше, чем раньше.

**Итого**

Ключевое слово async перед объявлением функции:

  1.  Обязывает её всегда возвращать промис.
  2.  Позволяет использовать await в теле этой функции.

Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:

   1. Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.
   2. Иначе вернётся результат промиса.

Вместе они предоставляют отличный каркас для написания асинхронного кода. Такой код легко и писать, и читать.

Хотя при работе с async/await можно обходиться без promise.then/catch, иногда всё-таки приходится использовать эти методы (на верхнем уровне вложенности, например). Также await отлично работает в сочетании с Promise.all, если необходимо выполнить несколько задач параллельно.
